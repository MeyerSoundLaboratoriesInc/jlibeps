/**
 * Copyright (c) 2001, 2006, Paul James Mutton
 * Copyright (c) 2006,2009, Thomas Abeel
 * Copyright (c) 2007, Arnaud Blouin
 * Copyright (c) 2007, 2017, Meyer Sound Laboratories Inc.
 * All rights reserved.
 * This file is part of jlibeps, merged with similar code from EPS Graphics, and
 * expanded by Meyer Sound Laboratories Inc.
 * jlibeps is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * jlibeps is distributed without any warranty; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 * PURPOSE. See the GNU General Public License for more details.
 * Project: http://www.jibble.org/
 */
package org.sourceforge.jlibeps.epsgraphics;

import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.Paint;
import java.awt.Shape;
import java.awt.Stroke;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.time.LocalDate;

/**
 * This class represents an EPS Document. Several EpsGraphics2D objects may
 * point to the same EpsDocument instance.
 * @author Paul James Mutton
 * @version 1.5.0
 */
public class EpsDocument {
	private double _minX;
	private double _minY;
	private double _maxX;
	private double _maxY;
	private boolean _clipSet;
	private final String _title;

	/**
	 * The Output Stream reference is provided for backward compatibility with
	 * older versions of the library, which allowed the passing in of an Output
	 * Stream which the library then wrapped in a Buffered Writer. This approach
	 * is now deprecated as it is better to have the client construct the
	 * chained writer wrappers using Java's new-ish try-with-resources feature.
	 * Due to preferred constructor wrapping order, we need to nullify this
	 * potentially unused reference at declaration time.
	 */
	private OutputStream _outputStream = null;

	/**
	 * The StringWriter reference is provided for backward compatibility with
	 * older versions of the library, which allowed for in-memory EPS creation.
	 */
	private StringWriter _stringWriter = null;

	/**
	 * The Writer reference was previously generated by the library in its
	 * fully-qualified constructor, but is now passed in by the client in place
	 * of an Output Stream reference, as only the client can wrap the usage in
	 * try-with-resources and still control the execution order of EPS Export.
	 */
	private final Writer _writer;

	/**
	 * We need to remember which was the last EpsGraphics2D object to use this
	 * document container, as we need to replace the clipping region if another
	 * EpsGraphics2D object tries to use this document container.
	 */
	private EpsGraphics2D _lastG;

	/**
	 * Constructs an empty EpsDocument, for in-memory usage.
	 * This constructor does NOT write the header right away, as do the others,
	 * as the preferred usage is to instead invoke "toString()" on the
	 * EpsGraphics2D wrapper. This poorly enforced coupling is why this approach
	 * is now deprecated, as it causes too much confusion of state in an API
	 * that is primarily oriented around file-based output. If there is a strong
	 * need for in-memory EPS generation, it should probably be re-implemented
	 * from scratch using new API's and methodologies, as this library is old.
	 * @param title The title of the EPS Document
	 * @since 0.1
	 */
	@Deprecated
	public EpsDocument(final String title) {
		_title = title;

		_minX = Double.POSITIVE_INFINITY;
		_minY = Double.POSITIVE_INFINITY;
		_maxX = Double.NEGATIVE_INFINITY;
		_maxY = Double.NEGATIVE_INFINITY;

		_stringWriter = new StringWriter();

		_writer = new BufferedWriter(_stringWriter);
	}

	/**
	 * Constructs an empty EpsDocument that writes directly to a file, and
	 * writes the common header shared by all EPS files. It is premature to
	 * write the actual content at this point, as it may need to be constructed
	 * algorithmically or otherwise incrementally, with interim page offsets.
	 * Note that the bounds must be set before use, so those are passed in.
	 * This constructor is no longer preferred, as it prevents the client from
	 * using a try-with-resources block to better manage I/O life cycles.
	 * @param title The title of the EPS Document
	 * @param outputStream The @OutputStream to channel the EPS content to
	 * @param minX The x-coordinate of the EPS content top left corner
	 * @param minY The y-coordinate of the EPS content top left corner
	 * @param maxX The x-coordinate of the EPS content bottom right corner
	 * @param maxY The y-coordinate of the EPS content bottom right corner
	 * @throws IOException
	 * @throws IOException
	 * @since 0.1
	 */
	@Deprecated
	public EpsDocument(final String title, final OutputStream outputStream, final double minX, final double minY, final double maxX, final double maxY) throws
		IOException {
		this(new BufferedWriter(new OutputStreamWriter(outputStream)), title, minX, minY, maxX, maxY);

		// Cache the Output Stream passed in by the client, as they may need to
		// retrieve it later in a different part of their code structure where
		// they don't have access to the original reference.
		_outputStream = outputStream;
	}

	/**
	 * Constructs an empty EpsDocument that writes directly to a file, and
	 * writes the common header shared by all EPS files. It is premature to
	 * write the actual content at this point, as it may need to be constructed
	 * algorithmically or otherwise incrementally, with interim page offsets.
	 * Note that the bounds must be set before use, so those are passed in.
	 * The original library passed in a pre-constructed OutputStream and then
	 * wrapped it in a BufferedWriter chained to an OutputStream Writer chained
	 * to a FileOutputStream, but it is best to let the client construct a
	 * Writer of its choice and pass that in, as this allows all of the I/O
	 * wrappers to be constructed inside a try-with-resources block. If we still
	 * did that here, we would have to close the EPS Document immediately upon
	 * constructing it, which dramatically reduces the required flexibility of
	 * compositing an output page incrementally, and/or from several sources.
	 * @param writer The wrapped @Writer to channel the EPS content to
	 * @param title The title of the EPS Document
	 * @param minX The x-coordinate of the EPS content top left corner
	 * @param minY The y-coordinate of the EPS content top left corner
	 * @param maxX The x-coordinate of the EPS content bottom right corner
	 * @param maxY The y-coordinate of the EPS content bottom right corner
	 * @throws IOException
	 * @since 1.1.5
	 */
	public EpsDocument(final Writer writer, final String title, final double minX, final double minY, final double maxX, final double maxY) throws
		IOException {
		_title = title;

		_minX = minX;
		_minY = minY;
		_maxX = maxX;
		_maxY = maxY;

		_clipSet = false;

		_writer = writer;

		// Write the header immediately, to make sure it is at the top of the
		// EPS Document, as not all EPS clients are reliable otherwise.
		write(_writer);
	}

	/**
	 * Appends a line to the EpsDocument. A new line character is added to the
	 * end of the line when it is added. Note that this is not done in a
	 * platform-specific way via the System.lineSeparator() function, as it is
	 * the downstream consumer of the EPS document that matters more than the
	 * producer of the document.
	 * @param epsGraphics The @EpsGraphics2D graphics context for writing EPS content
	 * @param line The new content line to write to the EPS document
	 * @throws IOException
	 * @since 0.1
	 */
	@SuppressWarnings("nls")
	public synchronized void append(final EpsGraphics2D epsGraphics, final String line) throws IOException {
		// If the graphics context changed and wasn't previously null,
		// "redundantly" reset current attributes to trigger EPS commands.
		if(_lastG != null && !epsGraphics.equals(_lastG)) {
			final EpsGraphics2D lastG = _lastG;

			// We are being drawn on with a different EpsGraphics2D context.
			// We may need to update the clip, etc. from this new context.
			final Shape clip = epsGraphics.getClip();
			if(clip != null && !clip.equals(lastG.getClip())) {
				epsGraphics.setClip(clip);
			}

			final Color color = epsGraphics.getColor();
			if(color != null && !color.equals(lastG.getColor())) {
				epsGraphics.setColor(color);
			}

			final Color background = epsGraphics.getBackground();
			if(background != null && !background.equals(lastG.getBackground())) {
				epsGraphics.setBackground(background);
			}

			// We don't need this, as this only affects the stroke and font,
			// which are dealt with separately later on.
			// final AffineTransform transform = g.getTransform();
			// if ( ( transform != null ) && !transform.equals(
			// lastG.getTransform() ) ) {
			// g.setTransform( transform );
			// }

			final Paint paint = epsGraphics.getPaint();
			if((paint != null) && !paint.equals(lastG.getPaint())) {
				epsGraphics.setPaint(paint);
			}

			final Composite composite = epsGraphics.getComposite();
			if((composite != null) && !composite.equals(lastG.getComposite())) {
				epsGraphics.setComposite(composite);
			}

			final Font font = epsGraphics.getFont();
			if((font != null) && !font.equals(lastG.getFont())) {
				epsGraphics.setFont(font);
			}

			final Stroke stroke = epsGraphics.getStroke();
			if((stroke != null) && !stroke.equals(lastG.getStroke())) {
				epsGraphics.setStroke(stroke);
			}
		}

		// Replace the cached graphics context for future change detection.
		_lastG = epsGraphics;

		// Now we have enough settings established for writing a content line.
		// :NOTE: This is not done in a platform-specific way via the
		// System.lineSeparator() function, as it is the downstream consumer of
		// the EPS document that matters more than the producer of the document.
		_writer.write(line + "\n");
	}

	/**
	 * This function finishes the EPS document and then closes it.
	 * This function is provided strictly for backward compatibility, as older
	 * versions of this library were written before the try-with-resources
	 * feature was added to Java, which obviates the need for invoking close().
	 * @throws IOException
	 * @since 0.1
	 */
	@Deprecated
	public synchronized void close() throws IOException {
		// If the in-memory approach was initiated, do nothing.
		if(_stringWriter != null) {
			return;
		}

		// Always finish the EPS Document before closing it.
		finish();

		// Close the EPS document, automatically flushing it first.
		_writer.close();
	}

	/**
	 * This function finishes the EPS document by writing its footer and then
	 * flushing the buffer.
	 * This function is meant to replace the older close() function when this
	 * library is passed a pre-constructed writer that was defined inside a
	 * try-with-resources block.
	 * @throws IOException
	 * @since 1.1.5
	 */
	public synchronized void finish() throws IOException {
		// Always write a page footer when finishing an EPS Document.
		writeFooter(_writer);
	}

	/**
	 * This function flushes the EPS document by flushing its referenced writer.
	 * @throws IOException
	 * @since 0.1
	 */
	public synchronized void flush() throws IOException {
		_writer.flush();
	}

	/**
	 * Simple getter function for the cached maximum x-coordinate.
	 * @return The x-coordinate of the EPS content bottom right corner
	 * @since 0.1
	 */
	public final double getMaxX() {
		return _maxX;
	}

	/**
	 * Simple getter function for the cached maximum y-coordinate.
	 * @return The y-coordinate of the EPS content bottom right corner
	 * @since 0.1
	 */
	public final double getMaxY() {
		return _maxY;
	}

	/**
	 * Simple getter function for the cached minimum x-coordinate.
	 * @return The x-coordinate of the EPS content top left corner
	 * @since 0.1
	 */
	public final double getMinX() {
		return _minX;
	}

	/**
	 * Simple getter function for the cached minimum y-coordinate.
	 * @return The y-coordinate of the EPS content top left corner
	 * @since 0.1
	 */
	public final double getMinY() {
		return _minY;
	}

	/**
	 * This is a simple getter function for the Output Stream, whether it is
	 * valid or not.
	 * This function is provided for backward-compatibility only, as clients are
	 * encouraged to instead pass in their own Writer and to manage I/O life
	 * cycles with Java's new-ish try-with-resources functionality.
	 * @return The cached Output Stream, even if is null and unused
	 * @since 0.1
	 */
	@Deprecated
	public final OutputStream getStream() {
		return _outputStream;
	}

	/**
	 * Returns the title of this EPS document.
	 * @return The title of this EPS document
	 * @since 0.1
	 */
	public synchronized String getTitle() {
		return _title;
	}

	/**
	 * Simple query for whether or not a clipping rectangle is set.
	 * @return true if a clipping rectangle is set; false otherwise
	 * @since 0.1
	 */
	public boolean isClipSet() {
		return _clipSet;
	}

	/**
	 * Simple setter function for whether or not a clipping rectangle is set.
	 * @param isClipSet Set to true if a clipping rectangle is set; false otherwise
	 * @since 0.1
	 */
	public void setClipSet(final boolean isClipSet) {
		_clipSet = isClipSet;
	}

	/**
	 * Updates the bounds of the current EPS document.
	 * @param x The x-coordinate that may expand the current bounds
	 * @param y The y-coordinate that may expand the current bounds
	 * @since 0.1
	 */
	public synchronized void updateBounds(final double x, final double y) {
		_maxX = Math.max(_maxX, x);
		_minX = Math.min(_minX, x);

		_maxY = Math.max(_maxY, y);
		_minY = Math.min(_minY, y);
	}

	/**
	 * Outputs the header of the EPS document to the specified Writer, complete
	 * with bounding box, title, scale factors and page translation offsets.
	 * @param writer The wrapped @Writer to channel the EPS content to
	 * @throws IOException
	 * @since 0.1
	 */
	public synchronized void write(final Writer writer) throws IOException {
		// Calculate the bounding box from the original mix/max values.
		final double originalWidth = Math.abs(_maxX - _minX);
		final double originalHeight = Math.abs(_maxY - _minY);

		// Write the header directly to the EPS Document.
		writeHeader(writer, originalWidth, originalHeight);

		// If we are writing to memory, copy the in-memory buffer to the
		// provided writer so that it can be saved to disc.
		if(_stringWriter != null) {
			final float offsetX = (float) -_minX;
			final float offsetY = (float) -_minY;

			// :NOTE: These may be inaccurate, and do not match the revised
			// methodology applied when a file based writer is passed to the
			// constructor. Also, this older approach does not set the scale.
			// The translation factor may different due to differences in
			// how, where, and when the header is placed on the page?
			writer.write(offsetX + " " + (offsetY) + " translate\n");

			_writer.flush();

			final StringBuffer buffer = _stringWriter.getBuffer();

			for(int i = 0; i < buffer.length(); i++) {
				writer.write(buffer.charAt(i));
			}

			writeFooter(writer);

			writer.flush();

			// It is safer to return now that we are done, than to use an
			// if-else clause and potentially have bugs or unintended side
			// effects if the flow of logic changes.
			return;
		}

		// Calculate the Aspect Ratio, based on the content width and height.
		// :TODO: Flag this as optional behavior, otherwise preserving units.
		// final float aspectRatio = originalWidth / originalHeight;

		// Calculate the scale factor of the full layout to a typical page
		// layout, using US-biased 8.5 inches at 72 pixels per inch. This is
		// specific to the needs of importing into Illustrator, but the
		// resulting file can easily be rescaled without loss of resolution.
		// :NOTE: The original author's assumptions that the bounding box
		// avoids clipping and ensures proper margins, is entirely incorrect.
		// :NOTE: EPS probably still only supports single-precision floats.
		// :TODO: Pass in the preferred page format vs. assuming US Letter, but
		// bear in mind that experiments with other page formats did not pan out
		// well at all. Is EPS crippled in this regard, compared to PostScript?
		// :TODO: Try again to experiment with Landscape Mode page orientation.
		final float pageWidth = 8.5f * 72f;
		final float pageHeight = 11f * 72f;
		final float scaleFactor = (float) Math.min(pageWidth / originalWidth, pageHeight / originalHeight);
		final float adjustedMinX = (float) Math.max((_minX * scaleFactor), 0d);
		final float adjustedMinY = (float) Math.max((_minY * scaleFactor), 0d);
		// final float adjustedMaxY = ( float ) Math.min( ( originalHeight *
		// scaleFactor ), pageHeight );

		// Write the scale factor and translation offsets for the overall page.
		writer.write(scaleFactor + " " + scaleFactor + " scale\n");
		writer.write(adjustedMinX + " " + (pageHeight - adjustedMinY) + " translate\n");

		// In order to ensure that the header, scale factor, and translation
		// offsets, appear before the content, we must flush the buffer now.
		writer.flush();
	}

	/**
	 * Write the footer for the current EPS document.
	 * @param writer The wrapped @Writer to channel the EPS content to
	 * @throws IOException
	 * @since 0.1
	 */
	public synchronized void writeFooter(final Writer writer) throws IOException {
		// Close the PostScript encapsulation of the main content before writing
		// the footer, using the PostScript "grestore" command.
		writer.write("grestore\n");

		// If we had set a clipping rectangle, that had its own PostScript
		// encapsulation that needs its graphics context to be taken off the
		// stack via the PostScript "grestore" command, then do so now.
		if(isClipSet()) {
			writer.write("grestore\n");
		}

		// EPS Footers are mostly just "EOF" as the format is single-page only.
		writer.write("showpage\n");
		writer.write("\n");
		writer.write("%%EOF");

		// Not strictly necessary, it does no harm to flush a writer "just in
		// case". This protects against any writes done on deferred threads.
		writer.flush();
	}

	/**
	 * Outputs the header of the EPS document to the specified Writer, complete
	 * with bounding box, title, scale factors and page translation offsets.
	 * @param writer The wrapped @Writer to channel the EPS content to
	 * @param width The width of the desired bounding box for the EPS content
	 * @param height The height of the desired bounding box for the EPS content
	 * @throws IOException
	 * @since 0.1
	 */
	public synchronized void writeHeader(final Writer writer, final double width, final double height) throws IOException {
		// Grab the current date and time in ISO format so we can extract an
		// ISO-compatible locale-sensitive date at the level of resolution we
		// care about, which is probably just to the year/month/day.
		final LocalDate localDate = LocalDate.now();
		final String timeStamp = localDate.toString();

		// Round up the dimensions due to integer-only in EPS.
		final int widthAdjusted = (int) Math.ceil(width);
		final int heightAdjusted = (int) Math.ceil(height);

		// Write the header directly to the EPS Document.
		writer.write("%!PS-Adobe-3.0 EPSF-3.0\n");
		writer.write("%%Creator: jlibeps " + EpsGraphics2D.VERSION + ", https://sourceforge.net/projects/jlibeps/" + "\n");
		writer.write("%%Title: " + _title + "\n");
		writer.write("%%CreationDate: " + timeStamp + "\n");
		writer.write("%%BoundingBox: 0 0 " + widthAdjusted + " " + heightAdjusted + "\n");
		writer.write("%%DocumentData: Clean7Bit\n");
		writer.write("%%LanguageLevel: 2\n");
		writer.write("%%DocumentProcessColors: Black\n");
		writer.write("%%ColorUsage: Color\n");
		writer.write("%%Origin: 0 0\n");
		writer.write("%%Pages: 1\n");
		writer.write("%%Page: 1 1\n");
		writer.write("%%EndComments\n\n");

		// Set up a global PostScript graphics context to wrap the overall
		// document contents. We do this here, as this is also where we need to
		// set up the page scaling and translation factors.
		writer.write("gsave\n");
	}

}// class EpsDocument
